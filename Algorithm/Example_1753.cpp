/* [작성일] 2017.01.10
[문제] 최단경로 https://www.acmicpc.net/problem/1753
방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.
[입력]
첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1≤V≤20,000, 1≤E≤300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 
둘째 줄에는 시작 정점의 번호 K(1≤K≤V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 
이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 
서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.
[출력]
첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 
시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.
*/

//#define PROBLEM_1753
#ifdef PROBLEM_1753
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;

#define INF 1000000
class Dijkstra
{
private:
	priority_queue<pair<int, int>> queueVertex;
	vector<int> visited;
	vector<int> minDistance;
	vector<pair<int, int>> *graph;
	int nVertexCount;

public:
	Dijkstra()
	{

	}
	~Dijkstra()
	{
		delete[] graph;
	}

	void initDijkstra(int nCount)
	{
		nVertexCount = nCount;
		graph = new vector<pair<int, int>>[nVertexCount]();

		for (int i = 0; i<nVertexCount; i++)
		{
			minDistance.push_back(INF);
		}
	}

	void insertVertex(int nStartVertex, int nEndVertex, int nDistance)
	{
		graph[nStartVertex].push_back(make_pair(nEndVertex, nDistance));
	}

	void runDijkstra(int nStartNode)
	{
		queueVertex.push(make_pair(0, nStartNode));

		do
		{
			int nQueueVertex = queueVertex.top().second;
			int nQueueDistance = -queueVertex.top().first;
			queueVertex.pop();

			// 이미 방문한 노드인 경우 다시 pop
			while (find(visited.begin(), visited.end(), nQueueVertex) != visited.end())
			{
				if (queueVertex.empty()) return;
				nQueueVertex = queueVertex.top().second;
				nQueueDistance = -queueVertex.top().first;
				queueVertex.pop();
			}

			// 방문한 노드 저장
			visited.push_back(nQueueVertex);
			minDistance.at(nQueueVertex) = nQueueDistance;

			for (int i = 0; i<graph[nQueueVertex].size(); i++)
			{
				int nNextVertex = graph[nQueueVertex].at(i).first;
				int nNextDistance = graph[nQueueVertex].at(i).second;

				nNextDistance = minDistance.at(nQueueVertex) + nNextDistance;
				queueVertex.push(make_pair(-nNextDistance, nNextVertex));
			}

		} while (!queueVertex.empty());
	}

	void printDistance()
	{
		for (int i = 0; i<nVertexCount; i++)
		{
			if (minDistance.at(i) == INF)
				printf("INF\n");
			else
				printf("%d\n", minDistance.at(i));
		}
	}

	void modifyMinDistance(int nVertexIndex, int nDistance)
	{
		minDistance.at(nVertexIndex) = nDistance;
	}
};

int main()
{
	int nVertexCount;
	int nEdgeCount;
	scanf("%d%d", &nVertexCount, &nEdgeCount);

	Dijkstra* sort = new Dijkstra;
	sort->initDijkstra(nVertexCount);

	int nStartNode;
	scanf("%d", &nStartNode);
	sort->modifyMinDistance(nStartNode - 1, 0);

	int u, v, w;
	while (nEdgeCount-- > 0)
	{
		scanf("%d%d%d", &u, &v, &w);

		sort->insertVertex(u - 1, v - 1, w);
	}

	sort->runDijkstra(nStartNode - 1);
	sort->printDistance();

	delete sort;

	return 0;
}
#endif